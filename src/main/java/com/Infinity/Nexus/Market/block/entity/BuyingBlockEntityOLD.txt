package com.Infinity.Nexus.Market.block.entity;

import com.Infinity.Nexus.Market.component.MarketDataComponents;
import com.Infinity.Nexus.Market.component.TicketItemComponent;
import com.Infinity.Nexus.Market.config.ModConfigs;
import com.Infinity.Nexus.Market.item.ModItemsMarket;
import com.Infinity.Nexus.Market.itemStackHandler.RestrictedItemStackHandler;
import com.Infinity.Nexus.Market.market.SQLiteHistoryCacheAdapter;
import com.Infinity.Nexus.Market.market.SQLitePlayerBalanceAdapter;
import com.Infinity.Nexus.Market.market.SQLiteUnifiedMarketAdapter;
import com.Infinity.Nexus.Market.screen.buying.BuyingMenu;
import com.Infinity.Nexus.Market.utils.ItemStackHandlerUtils;
import net.minecraft.ChatFormatting;
import net.minecraft.core.BlockPos;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.ComponentUtils;
import net.minecraft.network.chat.HoverEvent;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.ContainerData;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.state.BlockState;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class BuyingBlockEntityOLD extends AbstractMarketBlockEntity {
    private static final int TICKET_SLOT = 0;
    private static final int AUTO_SLOT = 1;
    private int progress = 0;
    private int maxProgress = ModConfigs.buyingTicksPerOperation;

    public BuyingBlockEntityOLD(BlockPos pPos, BlockState pBlockState) {
        super(ModBlockEntities.BUYING_MACHINE_BE.get(), pPos, pBlockState, 2);
    }

    @Override
    protected RestrictedItemStackHandler createItemHandler(int slots) {
        return new RestrictedItemStackHandler(slots) {
            @Override
            protected void onContentsChanged(int slot) {
                super.onContentsChanged(slot);
                setChanged();
                if (level != null && !level.isClientSide) {
                    level.sendBlockUpdated(getBlockPos(), getBlockState(), getBlockState(), 3);
                }
            }

            @Override
            public boolean isItemValid(int slot, @NotNull ItemStack stack) {
                return switch (slot) {
                    case 0 -> stack.is(ModItemsMarket.TICKET.get());
                    case 1 -> true;
                    default -> false;
                };
            }

            @Override
            public @NotNull ItemStack extractItem(int slot, int amount, boolean simulate, boolean fromAutomation) {
                if (slot == 1) {
                    return super.extractItem(slot, amount, simulate, false);
                }
                return super.extractItem(slot, amount, simulate, fromAutomation);
            }

            @Override
            public ItemStack insertItem(int slot, ItemStack stack, boolean simulate) {
                if (slot == 0) {
                    return stack;
                }
                return super.insertItem(slot, stack, simulate);
            }
        };
    }

    @Override
    protected ContainerData createContainerData() {
        return new ContainerData() {
            @Override
            public int get(int pIndex) {
                return switch (pIndex) {
                    case 0 -> progress;
                    case 1 -> maxProgress;
                    case 2 -> owner == null ? 0 : 1;
                    case 3 -> ownerName == null ? 0 : 1;
                    default -> 0;
                };
            }

            @Override
            public void set(int pIndex, int pValue) {
                switch (pIndex) {
                    case 0 -> progress = pValue;
                    case 1 -> maxProgress = pValue;
                    case 2 -> owner = pValue == 1 ? "" : null;
                    case 3 -> ownerName = pValue == 1 ? "" : null;
                }
            }

            @Override
            public int getCount() {
                return 4;
            }
        };
    }

    @Override
    protected int getEnergyCapacity() {
        return ModConfigs.buyingEnergyCapacity;
    }

    @Override
    protected int getEnergyTransfer() {
        return ModConfigs.buyingEnergyTransfer;
    }

    @Override
    public Component getDisplayName() {
        return Component.translatable("block.infinity_nexus_market.buying_machine");
    }

    @Nullable
    @Override
    public AbstractContainerMenu createMenu(int pContainerId, Inventory pPlayerInventory, Player pPlayer) {
        return new BuyingMenu(pContainerId, pPlayerInventory, this, this.data, this.itemHandler);
    }

    public void tick(Level pLevel, BlockPos pPos, BlockState pState) {
        if (pLevel.isClientSide) return;

        if (itemHandler.getStackInSlot(TICKET_SLOT).isEmpty()) {
            return;
        }

        if(owner == null || ownerName == null) {
            return;
        }

        if (autoEnabled) {
            autoBuyInMarket();
        }
    }

    public void autoBuyInMarket() {
        if (!(level instanceof ServerLevel serverLevel)) return;

        BuyRequest request = prepareBuyRequest();
        if (request == null) return;

        executeBuyTransaction(serverLevel, request, true);
    }

    public boolean selfBuyInMarket() {
        if (!(level instanceof ServerLevel serverLevel)) return false;

        BuyRequest request = prepareBuyRequest();
        if (request == null) return false;


        return executeBuyTransaction(serverLevel, request, false) > 0;
    }

    public void processManualBuy(ServerPlayer player) {
        if (player == null) return;

        ItemStack ticket = itemHandler.getStackInSlot(TICKET_SLOT).copy();
        if (!ticket.has(MarketDataComponents.TICKET_ITEM.get())) {
            player.displayClientMessage(Component.translatable("message.infinity_nexus_market.invalid_ticket"), false);
            return;
        }

        boolean success = selfBuyInMarket();

        if (success && !ticket.isEmpty() && !ticket.is(net.minecraft.world.item.Items.AIR)) {
            TicketItemComponent itemComponent = ticket.get(MarketDataComponents.TICKET_ITEM.get());
            ItemStack item = itemComponent.toItemStack();
            double price = itemComponent.getValue();

            Component itemComponentMsg = ComponentUtils.wrapInSquareBrackets(item.getHoverName())
                    .withStyle(style -> style.withColor(ChatFormatting.AQUA)
                            .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_ITEM,
                                    new HoverEvent.ItemStackInfo(item))));

            Component priceComponent = Component.literal(String.format("%.2f", price))
                    .withStyle(ChatFormatting.GOLD);

            Component msg = Component.translatable(
                    "message.infinity_nexus_market.buy_success_item",
                    ModConfigs.prefix, item.getCount(), itemComponentMsg, priceComponent
            );

            player.displayClientMessage(msg, false);
        } else if (!success) {
            player.displayClientMessage(Component.translatable("message.infinity_nexus_market.buy_fail", ModConfigs.prefix), false);
        }
    }
    private BuyRequest prepareBuyRequest() {
        ItemStack ticket = itemHandler.getStackInSlot(TICKET_SLOT);
        if (ticket.isEmpty() || !ticket.has(MarketDataComponents.TICKET_ITEM.get())) {
            return null;
        }

        TicketItemComponent itemComponent = ticket.get(MarketDataComponents.TICKET_ITEM.get());
        ItemStack stack = itemComponent.toItemStack();
        double value = autoEnabled ? Math.max(itemComponent.getValue(), autoPrice) : itemComponent.getValue();
        int desiredAmount = autoMinAmount > 0 ? autoMinAmount : stack.getCount();
        UUID buyerUUID = owner != null ? UUID.fromString(owner) : null;

        return new BuyRequest(stack, value, desiredAmount, buyerUUID);
    }
    private int executeBuyTransaction(ServerLevel serverLevel, BuyRequest request, boolean isAuto) {
        if (level == null) {
            return 0;
        }

        SQLiteUnifiedMarketAdapter market = SQLiteUnifiedMarketAdapter.get((ServerLevel) level);
        SQLitePlayerBalanceAdapter balances = new SQLitePlayerBalanceAdapter();
        List<SQLiteUnifiedMarketAdapter.SaleEntry> sales = new ArrayList<>(market.getSales((ServerLevel) level));

        int bought = 0;
        double totalCost = 0;

        for (SQLiteUnifiedMarketAdapter.SaleEntry entry : sales) {
            if (bought >= request.desiredAmount) break;

            if (isAuto && entry.seller != null  && entry.seller.equals(request.buyerUUID)) continue;

            if (!isValidPurchase(entry, request)) continue;

            int toBuy = Math.min(entry.quantity, request.desiredAmount - bought);
            double cost = entry.price * toBuy;

            if (!canAffordAndFit(balances, request.buyerUUID, cost, entry.item, toBuy)) break;

            TransactionResult result = processTransaction(market, balances, entry, request.buyerUUID,  toBuy, cost);
            bought += result.quantity;
            totalCost += result.cost;

            notifyOwnerIfNeeded(serverLevel, result.itemStack, result.quantity, result.cost);
            updateServerMarketHistory(serverLevel, entry, result.quantity);
        }

        return bought;
    }

    private boolean isValidPurchase(SQLiteUnifiedMarketAdapter.SaleEntry entry, BuyRequest request) {
        return ItemStack.isSameItemSameComponents(entry.item, request.stack) &&
                entry.price <= request.value;
    }

    private boolean canAffordAndFit(SQLitePlayerBalanceAdapter balances, UUID buyerUUID, double cost, ItemStack item, int quantity) {
        return (buyerUUID == null || balances.getBalance(buyerUUID) >= cost) &&
                ItemStackHandlerUtils.canInsertItemAndAmountIntoOutputSlot(item.getItem(), quantity, AUTO_SLOT, itemHandler);
    }

    private TransactionResult processTransaction(SQLiteUnifiedMarketAdapter market,
                                                 SQLitePlayerBalanceAdapter balances, SQLiteUnifiedMarketAdapter.SaleEntry entry,
                                                 UUID buyerUUID, int quantity, double cost) {

        balances.subBalance(buyerUUID, ownerName, cost);
        // Incrementa total_compras para o comprador
        com.Infinity.Nexus.Market.market.SQLiteManager.incrementPlayerStats(buyerUUID.toString(), 0.0, 0.0, 0, 1);

        if (entry.seller != null && ownerName != null) {
            balances.addBalance(entry.seller, entry.sellerName != null ? entry.sellerName : "Unknown", cost);
            // Incrementa total_vendas para o vendedor
            com.Infinity.Nexus.Market.market.SQLiteManager.incrementPlayerStats(entry.seller.toString(), 0.0, 0.0, 1, 0);
            balances.subBalance(UUID.fromString(owner), ownerName != null ? ownerName : "Unknown", cost);
        }


        if (entry.quantity == quantity) {
            market.removeSale(entry, (ServerLevel) level);
        } else {
            entry.quantity -= quantity;
            entry.item.setCount(entry.quantity);
        }
        ItemStack toInsert = entry.item.copy();
        toInsert.setCount(quantity);
        postItemInSlot(toInsert);

        return new TransactionResult(quantity, cost, toInsert);
    }

    private void notifyOwnerIfNeeded(ServerLevel serverLevel, ItemStack item, int quantity, double cost) {
        if (autoNotify && owner != null) {
            Player ownerPlayer = serverLevel.getPlayerByUUID(UUID.fromString(owner));
            if (ownerPlayer != null) {
                Component itemComponentMsg = ComponentUtils.wrapInSquareBrackets(item.getHoverName())
                        .withStyle(style -> style.withColor(ChatFormatting.AQUA)
                                .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_ITEM,
                                        new HoverEvent.ItemStackInfo(item))));
                Component priceComponent = Component.translatable("gui.infinity_nexus_market.tooltip.price_value",
                        String.format("%.2f", cost)).withStyle(ChatFormatting.GOLD);
                Component msg = Component.translatable(
                        "message.infinity_nexus_market.buy_success_item",
                        ModConfigs.prefix,
                        quantity,
                        itemComponentMsg,
                        priceComponent
                );
                ownerPlayer.displayClientMessage(msg, false);
            }
        }
    }

    private void updateServerMarketHistory(ServerLevel serverLevel, SQLiteUnifiedMarketAdapter.SaleEntry entry, int quantity) {
        if (level != null) {
            SQLiteUnifiedMarketAdapter unifiedMarket = SQLiteUnifiedMarketAdapter.get(serverLevel);
            for (SQLiteUnifiedMarketAdapter.ServerEntry serverEntry : unifiedMarket.getServerItemsAsServerEntry(serverLevel)) {
                if (ItemStack.isSameItemSameComponents(serverEntry.item, entry.item)) {
                    SQLiteHistoryCacheAdapter.get().addTransaction(entry.item, quantity, entry.price, entry.seller.toString(), entry.sellerName, serverLevel);
                    break;
                }
            }
        }
    }
    private static class BuyRequest {
        final ItemStack stack;
        final double value;
        final int desiredAmount;
        final UUID buyerUUID;

        BuyRequest(ItemStack stack, double value, int desiredAmount, UUID buyerUUID) {
            this.stack = stack;
            this.value = value;
            this.desiredAmount = desiredAmount;
            this.buyerUUID = buyerUUID;
        }
    }

    private static class TransactionResult {
        final int quantity;
        final double cost;
        final ItemStack itemStack;

        TransactionResult(int quantity, double cost, ItemStack itemStack) {
            this.quantity = quantity;
            this.cost = cost;
            this.itemStack = itemStack;
        }
    }

    public void postItemInSlot(ItemStack stack) {
        ItemStackHandlerUtils.insertItem(AUTO_SLOT, stack, false, itemHandler);
    }
}